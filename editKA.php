<?php
error_reporting(E_ALL);
ini_set("display_errors", 1);

/*
EDIT KNOWLEDGE ARTICLE
----------------------
A Knowledge Article (KA script) is a PHP script which generates a
simple HTML page for display. Only certain HTML entities arranged
in specific ways are allowed to be generated by a KA script. The
script you are currently looking at is NOT a KA script; however, it is
an editor for KA scripts. Mainly it modifies KA scripts by
changing the HTML they generate. Author: Sameh R. Labib 4/27/2011.
*/

session_start();

global $dom;

$docRoot = $_SERVER["DOCUMENT_ROOT"];

require_once("$docRoot/web/includes/login_funcs.php");
require_once("$docRoot/web/includes/db_vars.php");
require_once("$docRoot/web/includes/header_footer.php");

// User must be logged in and be someone special.
if (!user_isloggedin() || !user_type_cookieIsSet()) {
  form_destroy();
  $host = $_SERVER['HTTP_HOST'];
  header("Location: http://{$host}/web/login.php");
  exit;
}
if ($_COOKIE['user_type'] != 1) {
  form_destroy();
  die('Script aborted #3098. -Programmer.');
}

// Cancel if requested.
if (isset($_POST['cancel'])) {
  form_destroy();
  $host = $_SERVER['HTTP_HOST'];
  $uri = $_SERVER['PHP_SELF'];
  header("Location: http://$host$uri");
  exit;
}

// If back was requested:
if (isset($_POST['back'])) {
  $_SESSION['EKA_mode'] = 'show_L1_edit_form';
  $_SESSION['EKA_nodeID'] = $_SESSION['EKA_old_nodeID'];
  $_SESSION['EKA_intendedFocusAfterL1Edit'] = $_SESSION['EKA_old_intendedFocusAfterL1Edit'];
}

if (isSet($_SESSION['EKA_mode'])) {
  $mode = $_SESSION['EKA_mode'];
} else {
  $mode = 'stageOne';
}

// ****MAIN*******************************************

if ($mode == 'stageOne') {
  getFileInfoForm();
  $_SESSION['EKA_mode'] = 'process the specify file URI form';
} elseif ($mode == 'process the specify file URI form') {
  procFileInfoForm();
  readFileIntoString();
  separateIntoThree(); // beforeTheHTML, theHTML, afterTheHTML
  loadIntoTreeNSes();  // Use this function only the first time this needs to be done.
  $_SESSION['EKA_nodeID'] = NULL;
  $_SESSION['EKA_intendedFocusAfterL1Edit'] = 'all';
  $_SESSION['EKA_mode'] = 'show L1 edit form';
  informSourceFileLoaded();
} elseif ($mode == 'show L1 edit form') {
  $dom = DOMDocument::loadXML($_SESSION['EKA_theHTML']);
  establishValueFor_nodeID();
  showL1editFormPage();

//Make sure next stage validates submitToken of the form.
} else {
  form_destroy();
  die('The script died for reason # 294875654. -Programmer.');
}




/* ****end MAIN****************************************
FUNCTIONS SECTION:
*/
function form_destroy() {
  $_SESSION['EKA_mode'] = 'stageOne';
  $_SESSION['EKA_submitToken'] = "";
  $_SESSION['EKA_scriptFileName'] = "";
  $_SESSION['EKA_scriptFileDir'] = "";
  $_SESSION['EKA_fstring'] = "";
  $_SESSION['EKA_beforeTheHTML'] = "";
  $_SESSION['EKA_theHTML'] = "";
  $_SESSION['EKA_afterTheHTML'] = "";
  $_SESSION['EKA_nodeID'] = NULL;
  $_SESSION['EKA_old_nodeID'] = NULL;
  $_SESSION['EKA_intendedFocusAfterL1Edit'] = "";
  $_SESSION['EKA_old_intendedFocusAfterL1Edit'] = "";

  return;
}




function getFileInfoForm() {
  $submitToken = time();
  $_SESSION['EKA_submitToken'] = $submitToken;

  site_header('Edit Knowledge Article');
  $php_self = $_SERVER['PHP_SELF'];
  $page_str = <<<EOPAGESTR

<p>A knowledge article is a PHP script which generates a simple HTML
page for display. Only certain HTML entities arranged in specific
ways are allowed on this kind of page. The script you are looking
at right now is an editor for a knowledge article. It edits the
HTML of a KA.</p>

<form action="$php_self" method="post" class="loginform">
  <fieldset>
  <legend>Specify</legend>
  <div>
    <label for="scriptFileName" class="fixedwidth">File Name</label>
    <input type="text" name="scriptFileName" id="scriptFileName" value="" size="36" maxlength="36"/>
  </div>
  <div>
    <label for="scriptFileDir" class="fixedwidth">Directory Path</label>
    <input type="text" name="scriptFileDir" id="scriptFileDir" value="" size="36" maxlength="90"/>
  </div>
  <div>
    <input type="hidden" name="submitToken" value="$submitToken">
  </div>
  <div class="buttonarea">
    <input type="submit" name="cancel" value="Cancel"/>
    <input type="submit" name="submit" value="Submit"/>
  </div>
  </fieldset>
</form>

EOPAGESTR;
  echo $page_str;
  site_footer();
  return;
}




function procFileInfoForm() {
  if (isset($_POST['submitToken'])) {
    $submitToken = $_POST['submitToken'];
  } else {
    $submitToken = "";
  }
  if ($submitToken != $_SESSION['EKA_submitToken']) {
    form_destroy();
    $host = $_SERVER['HTTP_HOST'];
    $uri = $_SERVER['PHP_SELF'];
    header("Location: http://$host$uri");
    exit;
  }

  if (isset($_POST['scriptFileName'])) {
    $scriptFileName = $_POST['scriptFileName'];
  } else {
    $scriptFileName = "";
  }
  if (isset($_POST['scriptFileDir'])) {
    $scriptFileDir = $_POST['scriptFileDir'];
  } else {
    $scriptFileDir = "";
  }

  if ( get_magic_quotes_gpc() ) {
    $scriptFileName = stripslashes($scriptFileName);
    $scriptFileDir = stripslashes($scriptFileDir);
  }

  $scriptFileName = trim($scriptFileName);
  $scriptFileDir = trim($scriptFileDir);

  /*
  Validate the scriptFileName by making sure:
    1. It's not too long.
    2. It's not too short.
  */
  $length = strlen($scriptFileName);
  if ($length > 36 OR $length < 1) {
    form_destroy();
    die('Problem with string length. Err 9899986988. -Programmer.');
  }
  /*
  Validate the scriptFileDir by making sure:
    1. It's not too long or short.
    2. It starts with a '/' and ends with a '/'.
  */
  $length = strlen($scriptFileDir);
  if ($length > 90 OR $length < 1) {
    form_destroy();
    die('Problem with string length. Err 3643348226. -Programmer.');
  }
  $beginning = strpos($scriptFileDir, '/');
  $temp = strrpos($scriptFileDir, '/');
  $length = strlen($scriptFileDir);
  $end =  $temp - ($length - 1);

  if ($beginning !== 0 OR $end !== 0) {
    form_destroy();
    die("The path string does not start and end with a '/' (2087). -Programmer.");
  }

  // EXPORTING
  $_SESSION['EKA_scriptFileName'] = $scriptFileName;
  $_SESSION['EKA_scriptFileDir'] = $scriptFileDir;

  return;
}




function readFileIntoString() {
  $docRoot = $_SERVER["DOCUMENT_ROOT"];
  $scriptFileDir = $_SESSION['EKA_scriptFileDir'];
  $scriptFileName = $_SESSION['EKA_scriptFileName'];
  $locatorStr = $docRoot . $scriptFileDir . $scriptFileName;
  $fstring = file_get_contents($locatorStr);
  if (!$fstring) {
    form_destroy();
    die('Failed to get contents of file. Err 652938277. -Programmer.');
  }
  $_SESSION['EKA_fstring'] = $fstring;
  return;
}




function separateIntoThree() {
/*
Separate fstring into three: beforeTheHTML, theHTML, afterTheHTML. Also,
to save session memory we will get rid of $_SESSION['EKA_fstring'] since
it is no longer needed.
*/
  $fstring = $_SESSION['EKA_fstring'];

  // A call to preg_match.
  // $matches[0] will be the text that matches the full pattern.
  // $matches[1] will be the text that matches the first parenthesized subpattern.
  // $matches[2] will be the text that matches the second parenthesized subpattern.
  // $matches[3] will be the text that matches the third parenthesized subpattern.
  if (preg_match('/(^.*<<<EOPAGESTR5)(.*)(EOPAGESTR5;.*$)/su', $fstring, $matches)) {
    // A match was found.
    $_SESSION['EKA_beforeTheHTML'] = $matches[1];
    $_SESSION['EKA_theHTML'] = $matches[2];
    $_SESSION['EKA_afterTheHTML'] = $matches[3];
  } else {
    form_destroy();
    die('A match was not found. Err 7429377. -Programmer.');
  }

  // To save session memory we will get rid of $_SESSION['EKA_fstring'] since
  // it is no longer needed.
  $_SESSION['EKA_fstring'] = "";
  
  return;
}




function informSourceFileLoaded() {
/*
The stage for mode "process the form" is near completion. This function will
send a message and form to the user's browser.
*/
  $submitToken = time();
  $_SESSION['EKA_submitToken'] = $submitToken;

  site_header('Edit Knowledge Article');
  $php_self = $_SERVER['PHP_SELF'];
  $page_str = <<<EOPAGESTR

<p>If you don't see any pase errors above (and see this) then
the source file has been loaded into memory successfully. Also it passed the
XML validation.</p>

<form action="$php_self" method="post" class="loginform">
  <fieldset>
  <legend>Choose:</legend>
  <div>
    <input type="hidden" name="submitToken" value="$submitToken">
  </div>
  <div class="buttonarea">
    <input type="submit" name="cancel" value="Cancel"/>
    <input type="submit" name="continue" value="Continue"/>
  </div>
  </fieldset>
</form>

EOPAGESTR;
  echo $page_str;
  site_footer();

  return;
}




function establishValueFor_nodeID() {
/*
This function establishes the appropriate value for $_SESSION['EKA_nodeID']
at the beginning of stage 'show L1 edit form'.

Q: What should nodeID value be representing (particularl here)?
A: It should be the child ID number of the last L1 element to have been
   edited. If the last L1 edit was a completed delete then nodeID
   needs to point to the element before that one (assuming it exists
   -- if at that point it you find it don't exist then the next rule applies).
   If there are no L1 elements then nodeID = NULL. If there are L1 elements
   but none have been edited yet then nodeID = 0.


Wait! Wait! Wait!
Q: I just remembered there is a variable called $_SESSION['EKA_old_nodeID'].
   How does it come into play?
A: It is used when the user hits the back button. At the begining of each
   instance of this script there is code triggered by the existence of
   $_POST['back']. If triggered this code will re-assign $_SESSION['EKA_nodeID']
   the value in $_SESSION['EKA_old_nodeID']. So, where this comes into play
   around here is that this means the following: Generally speaking we need to
   respect the value already stored in $_SESSION['EKA_nodeID'].

NOTE: As part of the design of this script and ecosystem I won't allow the user
      to delete the last L1 element.

NOTE: This function will only run one time during the session. It will do so
      as a result of the overall design (not becuse this function will force it
      to). This function will know it should execute its code by whether or not
      $nodeID == NULL.

So, here is the code will accomplish:
- Figure out if the main body of code for this function needs to execute.
- Figure out if the DOM tree is empty (as in: no L1 elements in it).
- If that is the case then this script should error out. 
- If that is not the case then set $_SESSION['EKA_nodeID'] to zero (0).
*/
  if ($_SESSION['EKA_nodeID'] == NULL) {
    if (domTreeIsEmpty()) {
      form_destroy();
      die('The DOM tree should never be empty. Err 582274. -Programmer.');
    } else {
      $_SESSION['EKA_nodeID'] = 0;
    }
  }
  return;
}




function domTreeIsEmpty() {
/*
This function was originally written to support establishValueFor_nodeID().
It will examin the DOM tree of the main document we are editing. It will 
return a boolean.
*/
  global $dom;
  $root = $dom->documentElement;
  $isEmpty = !($root->hasChildNodes());
  return $isEmpty;
}




function showL1editFormPage() {
/*
This is the Big Cahouna. It will send the L1 edit form to the user's browser.

This form will not be the same as the class="loginform" forms I've been having so far.
I'm building this from scratch.
*/
  /*
  Composing some elements of the form.
  */
  /*
  Composing $nodeDivs.
  */
  $nodeDivs = composeL1EditForm_nodeDivs();
  /*
  Composing $buttonsDiv.
  */
//  $buttonsDiv = composeL1EditForm_buttonsDiv();

//Put $ sign back in front of buttonsDiv in heredoc
//after debugging.

  /*
  Sending the form to the browser.
  */
  $submitToken = time();
  $_SESSION['EKA_submitToken'] = $submitToken;

  site_header('Edit Knowledge Article');
  $php_self = $_SERVER['PHP_SELF'];
  $page_str = <<<EOPAGESTR


<form action="$php_self" method="post">
$nodeDivs
buttonsDiv
  <div>
    <input type="hidden" name="submitToken" value="$submitToken">
  </div>
</form>


EOPAGESTR;
  echo $page_str;
  site_footer();
  return;
}




function composeL1EditForm_nodeDivs() {
/*
This function does what its name says it does.
*/

  /*
  Some things we should have a handle on.
  */
  global $dom;
  $root = $dom->documentElement;
  $children = $root->childNodes;
  $length = $children->length;
  $nodeID = $_SESSION['EKA_nodeID'];

  /*
  I'm thinking out-loud here while looking ot the specification I wrote
  in Yahoo! Notepad.
  
  We need to compose a string consisting of the node divs for a patricular
  range of child indices. So, the first thing we need to establish is the
  range. There are three types of ranges: all, local, toEnd. We need to
  have a value for the index of the first and last child in the range.
  */
  $focus = $_SESSION['EKA_intendedFocusAfterL1Edit'];
  if ($focus == 'all') {
    $first = 0;
    $last = ($length - 1);
  } elseif ($focus == 'local') {
    /*The range should be from the second node before nodeID to the second
    node after nodeID (assuming all these nodes exist - adjust appropriately)*/
    /*
    The players: $nodeID, 0, ($length - 1).
    We would prefer that $first = ($nodeID - 2).
    Our second preference is $first = ($nodeID - 1).
    Our last resort is $first = $nodeID.
    */
    $firstPref = ($nodeID - 2);
    $secondPref = ($nodeID - 1);
    if (!($firstPref < 0)) {
      $first = $firstPref;
    } elseif (!($secondPref < 0)) {
      $first = $secondPref;
    } else {
      $first = $nodeID;
    }
    /*
    Our first preference would be $last = ($nodeID + 2).
    Our second preferende would be $last = ($nodeID + 1).
    Our last resort is $last = $nodeID.
    */
    $firstPref = ($nodeID + 2);
    $secondPref = ($nodeID + 1);
    if (!($firstPref > ($length - 1))) {
      $last = $firstPref;
    } elseif (!($secondPref > ($length - 1))) {
      $last = $secondPref;
    } else {
      $last = $nodeID;
    }
  } elseif ($focus == 'toEnd') {
    /*The range should be from the second node before nodeID to the last
    node (assuming all these nodes exist - adjust appropriately)*/
    /*
    We would prefer that $first = ($nodeID - 2).
    Our second preference is $first = ($nodeID - 1).
    Our last resort is $first = $nodeID.
    */
    $firstPref = ($nodeID - 2);
    $secondPref = ($nodeID - 1);
    if (!($firstPref < 0)) {
      $first = $firstPref;
    } elseif (!($secondPref < 0)) {
      $first = $secondPref;
    } else {
      $first = $nodeID;
    }
    $last = ($length - 1);
  } else {
    form_destroy();
    die('Non-valid focus. Err 119410. -Programmer.');
  }

  $string = makeL1EditForm_nodeDivs($first, $last);
  return $string;
}




function composeL1EditForm_buttonsDiv() {
/*
This function does what its name says it does.
*/


  return;
}




function makeL1EditForm_nodeDivs($firstIN, $lastIN) {
/*
Returns a string containing the divs for the L1 edit form corresponding to
the L1 nodes within index range $firstIN to $lastIN inclusively.

Each div will have:
  - Rendering of the element.
  - Button holding (nodeSelected) the index of the element.
  - Select box (whatYouWantDone). Presenting relavent options only.
    (variable name contains an index)
  - Hidden variable (kdsL1ElementType).
    (variable name contains an index)
*/

  /*
  Some things we should have a handle on.
  */
  global $dom;
  $root = $dom->documentElement;
  $children = $root->childNodes;
  $nodeDivStr = "";

  /*
  Loop iterates through L1 nodes. Builds $nDivStr.
  */
  for ($x=$firstIN;$x <= $lastIN;$x++) {
    // Start the <div> for current node.
    $nodeDivStr .= "<div>\n";
    // Get the XHTML for current L1 node.
    $nodeXHTML = l1NodeString($x);
    // Escape the backslashes.
    $nodeXHTML =  entitizeBackslash($nodeXHTML);
    // Append it.
    $nodeDivStr .= $nodeXHTML;

    /*
    Add the form fields for this L1 node.
    
    The field's name will be node.
    However the node's submit field will be called nodeNumber.
    Node (uncapitalized) will be an array.
    The index of node array will be the index of the child/node in the DOM.
    Each node element will also be an array.
    The later will have the following indices:
     (category, task, catForIns)
    */
    
    /*
    Add a hidden form variable related to this node.
    It will specify the category of the node:
     (pOrBlockquote, h, pre, hr, table, list, image, remark)
    */
    $category = l1NodeCategory($x);
    // Append the hidden variable.
    $nodeDivStr .= "<div>\n<input type=\"hidden\" name=\"node[$x]['category']\" value=\"$category\">\n";

    /*
    Add a select box which contains the choices for task. Only the tasks which are
    relavent to the particular category of the node will be presented. Generally
    speaking these are the choices' values:
      (edit, insert, delete)
    */
    $nodeDivStr .= "<select name=\"node[$x]['task']\">\n";
    $nodeDivStr .= "<option value=\"insert\">insert</option>\n";
    if ($x >= 1) {
      $nodeDivStr .= "<option value=\"delete\">delete</option>\n";
    }
    if ($category != "hr") {
      $nodeDivStr .= "<option value=\"edit\">edit</option>\n";
    }
    $nodeDivStr .= "</select>\n";

    /*
    Add a select box which contains the choices for catForIns. This value
    is for the case where the user chooses insert as the task to accomplish.
    That way we'll know what category node is to be inserted.
    */
    $nodeDivStr .= "<select name=\"node[$x]['catForIns']\">\n";
    $nodeDivStr .= "<option value=\"pOrBlockquote\">p or blockquote</option>\n";
    $nodeDivStr .= "<option value=\"h\">h</option>\n";
    $nodeDivStr .= "<option value=\"pre\">pre</option>\n";
    $nodeDivStr .= "<option value=\"hr\">hr</option>\n";
    $nodeDivStr .= "<option value=\"table\">table</option>\n";
    $nodeDivStr .= "<option value=\"list\">list</option>\n";
    $nodeDivStr .= "<option value=\"image\">image</option>\n";
    $nodeDivStr .= "<option value=\"remark\">remark</option>\n";
    $nodeDivStr .= "</select>\n";

    /*
    Add a submit button whose name is nodeNumber. Its value will be $x.
    */
    $nodeDivStr .= "<input type=\"submit\" name=\"nodeNumber\" value=\"$x\"/>\n";

    // End the <div>s for current node (including the one for the form fields).
    $nodeDivStr .= "</div>\n</div>\n";
  }

  return $nodeDivStr;
}




function l1NodeCategory($x) {
/*
This function will inspect the L1 node and determine its category.
The category can be: pOrBlockquote, h, pre, hr, table, list, image, remark.
The function returns the category.
*/
  global $dom;
  $root = $dom->documentElement;
  $children = $root->childNodes;

  $node = $children->item($x);
  $nodeName = $node->nodeName;

  switch($nodeName) {
    case p:
      $category = "pOrBlockquote";
      break;
    case blockquote:
      $category = "pOrBlockquote";
      break;
    case h2:
      $category = "h";
      break;
    case h3:
      $category = "h";
      break;
    case h4:
      $category = "h";
      break;
    case h5:
      $category = "h";
      break;
    case pre:
      $category = "pre";
      break;
    case hr:
      $category = "hr";
      break;
    case table:
      $category = "table";
      break;
    case ol:
      $category = "list";
      break;
    case ul:
      $category = "list";
      break;
    case div:
      // If the first grandchild's nodeName is img then $category is image.
      if ($node->hasChildNodes()) {
        $grandChildren = $node->childNodes;
        $firstGChild = $grandChildren->item(0);
        $fGCNodeName = $firstGChild->nodeName;
        if ($fGCNodeName == "img") {
          $category = "image";
          break;
        }
      }
      // If there is a class attribute whose value is remarkbox then
      // $category is remark.
      $classAtt = $node->getAttribute("class");
      if ($classAtt == "remarkbox") {
        $category = "remark";
        break;
      }
      form_destroy();
      die('The div is weird. Err 5187854. -Programmer.');
    default:
      form_destroy();
      die('Node category undefined. Err 6644297. -Programmer.');
  }

  return $category;
}




function l1NodeString($x) {
/*
This function returns an XHTML string corresponding to the L1 node indexed
by $x. The return string should be properly formatted with white space to
make it look good in browser's view source.
*/
  global $dom;
  // Get document element of main document.
  $root = $dom->documentElement;
  // Get its children.
  $l1Nodes = $root->childNodes;
  // Get pointer to the L1 node we want to print.
  $srcNode = $l1Nodes->item($x);

  // Create a new tree.
  $newdoc = new DOMDocument();
  // Designate that serialized output should be formatted.
  $newdoc->formatOutput = TRUE;
  // Make a copy of the old node from old tree.
  $copyNode = $srcNode->cloneNode(TRUE);
  // Associate the new node with the new tree.
  $copyNode = $newdoc->importNode($copyNode,TRUE);
  // Graft the new node into the new tree.
  // If this works then this is a way to create a document's
  // document element which I haven't read about in any documentation.
  $newdoc->appendChild($copyNode);
  // Serialize and print the new tree.
  // I'm using saveHTML instead of saveXML to avoid the the XML type
  // declaration in output.
  $nodeStr = $newdoc->saveHTML();

  return $nodeStr;
}




// BOTTOM *******************************************

// KEEP AT BOTTOM
// Use later.
function entitizeBackslash($string_IN) {
/*
Replace all backslashes with the entities &#92;.
See NOTE in loadIntoTreeNSes() which relates to this topic for explanation
of why this function exists.

NOTE: Compare to entitizeDollarNBackslash($string_IN).
      When tree nodes are going to be displayed in the browser
      directly (as opposed to going to a heredoc first)
      there is no need to convert the dollar sign character.
*/
  $string = str_replace("\\", "&#92;", $string_IN);
  return $string;
}




// KEEP AT BOTTOM
// Use later.
function entitizeDollarNBackslash($string_IN) {
/*
Replace all dollar signs and backslashes with the entities &#36; and &#92;.
See NOTE in loadIntoTreeNSes() which relates to this topic for explanation
of why this function exists.
*/
  $needle = array("$", "\\");
  $replacements = array("&#36;", "&#92;");
  $string = str_replace($needle, $replacements, $string_IN);
  return $string;
}




/*
SAMPLE:
//DEBUG CODE
$dom->formatOutput = TRUE;
$output = $dom->saveXML();
$output = entitizeDollarNBackslash($output);
print $output;
form_destroy();
die('All done. -Programmer.');
//END DEBUG
      
KEEP AT BOTTOM
*/




/*
NOTE: As part of the design of this script and ecosystem I won't allow
      the user to delete the last L1 element.
      
KEEP AT BOTTOM
*/




/*
NOTE: Don't forget to use entitizeDollarNBackslash($string_IN)
      before writing to file.
      
KEEP AT BOTTOM
*/




// KEEP AT BOTTOM
// BECAUSE IT MESSES WITH TEXTWRANGLER EDITOR'S FUNCTIONALITY
function loadIntoTreeNSes() {
/*
For the first time only: load theHTML into a tree, serialize, and save to session.
The editKA.php script manipulates the XHTML content of a knowledge article using PHP's
DOMDocument object API. In order to manipulate this content we want it to be loaded
into a DOMDocument object which becomes serialized and passed into a session variable.
The reason we say 'for the first time only' is that this function is to be used only
one time (at the beginning of the program's execution) though simmilar functionality
will be needed throughout the program.

What this function does:
  o Prepare theHTML string to be loaded into $dom DOMDocument object.
    - A <ekabody> tag will enclose the existing XML elements.
    - Afterwards, a <!DOCKTYPE> element will be prepended.
  o Load theHTML string into $dom DOMDocument object.
  o Serialize the $dom DOMDocument object.
  o Save the serialized $dom DOMDocument object in a session variable.

NOTE:
  When theHTML gets loaded into the tree some funny things happen to some
  characters in the data:
    o UTF-8 characters in the range above ASCII get replaced with entities.
    o The character entities for the XML reserved characters remain untouched.
      (>, < and &).
    o The entities for characters in the ASCII range get replaced with their
      actual characters. (AND THIS CAN CAUSE PROBLEMS WITH WHAT THIS PROGRAM
      DOES.)
  The problem with that last bullet is as follows:
  My knowledge articles (which this program edits) maintain their data in a PHP
  heredoc. A heredoc is a string literal; in other words it's textual data
  within the code which gets interpreted. When it's interpreted PHP sees it as
  latin-1 encoded characters and the dollar sign and backslash have special
  meaning. Therefore, while coding this program I need to make sure those two
  characters in their raw form don't end up in the wrong place. 
*/

  $theHTML = $_SESSION['EKA_theHTML'];
  // to conserve memory
  $_SESSION['EKA_theHTML'] = "";
  
  /*
  This is the XML declaration.
  */
  $xmlDec = '<?xml version="1.0" encoding="UTF-8"?>';
  
  /*
  This is the document type declaration used for validation.
  */
  $dTDec = <<<DTDECSTR
<!DOCTYPE ekabody [
  <!ELEMENT ekabody (p|blockquote|h2|h3|h4|h5|pre|hr|table|ol|ul|div)*>
  <!ELEMENT p (#PCDATA|a|em|sup|sub|br)*>
  <!ELEMENT blockquote (#PCDATA|a|em|sup|sub|br)*>
  <!ELEMENT h2 (#PCDATA)>
  <!ELEMENT h3 (#PCDATA)>
  <!ELEMENT h4 (#PCDATA)>
  <!ELEMENT h5 (#PCDATA)>
  <!ELEMENT pre (#PCDATA|b)*>
  <!ELEMENT hr EMPTY>
  <!ELEMENT table (caption, tr+)>
  <!ELEMENT ol (li+)>
  <!ELEMENT ul (li+)>
  <!ELEMENT div (#PCDATA|p|img|div)*>
  <!ELEMENT tr (th|td)*>
  <!ELEMENT th (#PCDATA)>
  <!ELEMENT td (#PCDATA|p|blockquote|em|sup|sub)*>
  <!ELEMENT li (#PCDATA|br)*>
  <!ELEMENT em (#PCDATA)>
  <!ELEMENT sup (#PCDATA)>
  <!ELEMENT sub (#PCDATA)>
  <!ELEMENT b (#PCDATA)>
  <!ELEMENT a (#PCDATA)>
  <!ELEMENT br EMPTY>
  <!ELEMENT img EMPTY>
  <!ELEMENT caption (#PCDATA)>
  <!ATTLIST table
       class CDATA #FIXED "events"
       width CDATA #IMPLIED>
  <!ATTLIST em class NMTOKEN #IMPLIED>
  <!ATTLIST a href CDATA #REQUIRED>
  <!ATTLIST div class NMTOKEN #IMPLIED>
  <!ATTLIST img
       src CDATA #REQUIRED
       width CDATA #IMPLIED
       height CDATA #IMPLIED
       alt CDATA #IMPLIED>
]>
DTDECSTR;

  /*
  Add stuff to theHTML to prep it for the DOM parser.
  */
  $theHTML = $xmlDec . $dTDec . "<ekabody>" . $theHTML . "</ekabody>";
  
  $dom = new DOMDocument();
  $dom->preserveWhiteSpace = FALSE;
  $dom->loadXML($theHTML);
  if (!($dom->validate())) {
    form_destroy();
    die('Validation of source document has failed. Err 2612. -Programmer.');
  }

  $_SESSION['EKA_theHTML'] = $dom->saveXML();
  // To retrieve the tree in other stages of program execution do:
  // $dom = DOMDocument::loadXML($_SESSION['EKA_theHTML']);

  return;
}
?>